Проект Very Simple Remote Procedure Call (VSRPC) - очень простой удаленный
запуск процедур.

Версия: 0.9
Лицензия: BSD
Авторы: Alex Grinkov <a.grinkov@gmail.com>,
        Anton Shmigigilov <shmigirilov@gmail.com>

СТАТУС ДОКУМЕНТА.

Введение в VSRPC. Рекомендуется прочитать перед тем как смотреть исходники.
Ничего более подробного и достоверного чем сам исходник не планируется.


ПРЕАМБУЛА.

Любой программист знает, что любую программу (не очень маленькую)
нужно делить на программные модули, модули на функции и классы,
если используется модель ООП.  Чем больше программа, тем больше в ней
функций, классов и модулей.  Для больших проектов так же целесообразно
использование разделяемых библиотек.  Все это очень замечательно,
когда идет работа над одной программой. Разные люди могут сопровождать
разные модули, разные функции, разные классы.  Но существуют такие
программные комплексы (или аппаратно-програмные), которые состоят из
нескольких программ (пример UNIX, который состоит из огромного числа
маленьких прграмных утилит). Но это еще не самое страшное. Разработка ПО
становится еще сложнее, когда програмно-апппаратные комплексы состоят
из вычислительных машин различных архитектур и используют совершенно
различные операционные системы (или не используют их вообще). В
таких случаях для каждой конкретной задачи возникает необходимость
разработки программных протоколов взаимодейсвия програмного обеспечения
разных вычислительных систем по имеющимся аппаратным каналам (например,
Ethernet, USB, RS-232). Если бы было можно вызывать некоторые заранее
оговоренные функции на первой машине, а выполнялись бы они на второй и
результат бы возвращался обратно в первую машину, то задача могла бы
быть упращена. Проект VSRPC позиционируется для систематизации такой
задачи. Понятие RPC (Remote Procedure Call) хорошо известно програмистам
различных систем, это понятия сущесвует и в мире Windows и в мире UNIX
операционных систем. Еще одно применение RPC это взаимодейсвие программ
называемых 'frontend' и 'backend' или использование в качесве
клиент-серверной модели.


ОСНОВНЫЕ ЧЕРТЫ VSRPC.

1) Простота. Модуль vsrpc.c/vsrpc.h написан на чистом языке Си, отлажен
с использованием свободного компилятора номер один в мире GCC. VSRPC
самодостаточен и не требует ничего кроме стандартной библиотеки языка Си.
Большинсво настроек производится редактированием заголовочного файла
"vsrpc.h".

2) Переносимость. Т.к. модуль ни от чего особенно не зависит его можно
использовать даже в таких системах, где отсутсвует ОС (например ДОС или
однокристальный микроконтроллер). Модуль использует динамическое
выделение памяти, если ваша система не имеет стандартных функци malloc() и
free() вам всего лишь потребуется переписать функции vsrpc_malloc() и
vsrpc_free() включив в них вызовы тех функции, которые реализуют в вашей
системе управление памятью.

3) Универсальность. Независимость от протокола нижнего уровня.
VSRPC работает через двунаправленное соединение типа "труба".
Такое соединение обеспечивает протокол Интернет TCP или двунаправленое
соединение по RS-232. В дейсвительности VSRPC может работать и через общую
память, для этого достаточно подключить функции реализующие передечу 2-х
потоков данных. Для взаимодейсвия с транспортным протоколом (протоколом
нижнего уровня) необходимо определить 4 функции и заполнить 4 поля
структуру 'vsrpc' указателями на эти функции. 2 функции (read и write)
являются обязательнымы, именно эти функции реализуют дуплексный обмен
двух программ. 2 функуии (select и flush) являются необязательными, в их
качестве можно использовать т.н. "заглушки", или использовать нулевые
указатели (NULL). Функции read и write работают подобно
одноименным функциям в UNIX или POSIX. Функция select похожа на функцию
select в UNIX/POSIX, но принимает аргументы немного в другом формате.
Пример функции select в понятии VSRPC и использования select из Linux
прилагается, ровно как и пример прослойки для read и write. Функция VSRPC
select используется только для входного потока.
Если функция write буферезирована, то для отправки пакета необходимо
подключить функцию flush, по ней должно отправлятся то, что было уложено в
FIFO с использованием write. Функция flush используется только для выходного
потока.

4) Блочность обмена. Чтение входного потока и запись в выходной производятся
блочно. За счет этого должна быть хорошая производительность и маленький
"OVERHEAD".

5) При передаче аргументов и возврате результатов процедур используется
текстовый формат передачи аргументов. Это незначительно замедляет работу
(требуется вызывать функуии типа: snprintf, atoa, atoi), но упращает
отладку, анализ трафика, позволяет использовать терминальную программу
(такую как telnet или minicom) для вызова процедур на удаленном хосте.

6) VSRPC поддерживает не только удаленное выполнение процедур, но и 
встроенные функции для обмена данными. Передача данных может осуществляется
блочно как в текстовом, так и в бинарном виде. Тектовый способ передачи
удобен при отладке и при работе на машинах с различным чередованием байт
в слове (не требуется производить обмен байтов в слове).

7) Симметричность. VSRPC объеденяет две точки (два хоста) при этом
отличие их весьма условно. Считается, что тот, кто запрашивает процедуру
является клиентом, тот, на чьей стороне выполняется процедура - сервер.
Обе точки могут вызывать VSRPC процедуры на противопложных концах.

8) Все функции VSRPC омеют одинаковый прототип типа:
"char** some_vsrpc_func(vsrpc *obj, int argc, char * const argv[]);".
Принимаемые любой функцией аргументы подобны аргументам передаваемым
функции main, где argc - число аргументов, причем с учетом того, что первый
аргумент это само VSRPC имя функции, argv - массив указателей на текстовые
строки содержащие аргументы, argv[argc] - является указателем на NULL.
Функция может вернуть любое число значений в таком же формате как и
принимаемое argv, void функции должны возвращать NULL. Для формирования
списка возвращаемых значений удобно использовать функцию-помошника
vsrpc_list2argv().


ТЕРМИНОЛОГИЯ.

"Сервер" - та точка, которая в данный момент ждет имя процедуры и аргументы
от другой точки, та точка на стороне которой выполняется процедура.

"Клиент" - та точка которая в данный момент вызывает процедуру на стороне
"сервера" и ждет возвращаемых значений.

"Remote Call" (удаленный вызов). Клиент передает серверу имя процедуры и
агрументы для ее выполения, сервер выполняет на своей стороне одноименную
функцию и возвращает результаты ее выполения клиенту. Это обычный "Call".

"Callback" (обратный вызов). Если клиент запросил у сервера на выполнение
процедуру, а сервер, не вернул еще результаты ее выполнения клиенту, но уже
запрашивает процедуру у клиента, то такой запрос называется "callback".
Обратные вызовы можно запретить.

"Рекурентный вызов." Если одна сторона запросила у другой рузультаты выполения
функции (обычный "Remote Call" или "Callback"), но недождавщись ответа
(результатов выполнения процедуры) пытается вызвать еще одну процедуру,
то такая ситуация называется  - "Recursive Call". Рекурентные вызовы
протоколом VSRPC ЗАПРЕЩЕНЫ.

"Memory Block" (Блок памяти). Т.к. обмен данными может быть между
разными программами или даже разными процессорами, то передача адресов
или указателей не имеет никакого смысла. Для идентификации блока памяти
используется понятие Memory Block ID - сквозной номер блока в который
производится запись или из которого производится чтение. Как запись так и
чтение может производится по произвольному смещению. Блоки могут быть
статическими, в этом случае VSRPC никак не может их менять и динамичсекие
в таком случае возможно локальное и даже удаленное управление блоками памяти.
Максимальное число блоков памяти задано в "vsrpc.h". Максимальный размер
динамического блока так же ограничен из сображения безопастности.

"Permissions" (Права). Каждая точка (хост) имеет слово прав для ответной
стороны. Каждый единичный бит разрешает ответной стороне производить то или 
иное дейсвие. Например управление блоками памяти может быть замаскаровано,
можно разрешить чтение блоков и запретить запись или наоборот...


ДОПОЛНИТЕЛЬНЫЕ ВОЗМОЖНОСТИ.

1) Если вам нужна готовая реализациия TCP сервера и клиента на основе VSRPC
можете ознакомится с модулями vstcpd.c и vstcpc.c соответсвенно.

2) vstcps.c - компонент многопоточного TCP сервера без привязки к VSRPC.

3) Для автоматической генерации исходников с необходимыми вызовами функций
VSRPC (запрос, ожидание ответа, анализ возвращаемых кодов ошибок) можно
использовать shell сценарий "vsrpc_idl.sh". В качестве входного файла нужно
сформировать файл в формате VSIDL (Very Simple Interphace Description
Language) с прототипами необходымых функций. Такой подход конечно сужает
возможности VSRPC, но сущесвенно упращает работу по стыковке програмного
обеспечения, скрывая особенности архитектуры VSRPC внутри прослоек.


